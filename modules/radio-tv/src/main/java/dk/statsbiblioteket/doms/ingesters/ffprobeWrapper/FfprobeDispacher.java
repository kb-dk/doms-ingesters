package dk.statsbiblioteket.doms.ingesters.ffprobeWrapper;

import dk.statsbiblioteket.util.xml.DOM;
import dk.statsbiblioteket.util.xml.XPathSelector;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.validation.Schema;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by IntelliJ IDEA.
 * User: eab
 * Date: 11/17/11
 * Time: 1:06 PM
 *
 * This class facilitates a threaded batch processing of digitalAV material
 * the results return asynchronously, and data is processed as it arrives.
 *
 * Errors are handled here in when pushed from the Analyzer.
 *
 */
public class FfprobeDispacher implements CallBackEventHandler {

    private Map<String, String> files;  // maps <fileName, shardPID>
    private Map<String, String> failedFiles;  // maps <fileName, analysisError>
    private Map<String, Thread> runningThreads;  // maps <fileName, Thread>
    private XPathSelector xpathSelector;
    private DocumentBuilder docBuilder;


    public void FfprobeDispacher(Schema ffprobeSchema, HashMap<String, String> files){
         DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory
                .newInstance();
        documentBuilderFactory.setSchema(ffprobeSchema);
        documentBuilderFactory.setNamespaceAware(true);

        this.files = files;
        runningThreads = new HashMap<String, Thread>();
        failedFiles = new HashMap<String, String>();
        try {
            docBuilder = documentBuilderFactory.newDocumentBuilder();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            // TODO: Log this
            // TODO: we should not allow endless failures....
            // TODO: FATAL
            fatalException();
        }
        xpathSelector = DOM.createXPathSelector("ffprobe",
                "http://www.ffmpeg.org/schema/ffprobe");
    }

    private void fatalException() {
        System.exit(-1);
    }

    /**
     * Starts a thread per file, that calls the <code>incommingEvents</code>
     * method to handle the technical metadata.
     */
    public void startBatch(){

        while(!this.files.isEmpty()){
            String name = files.get(0);
            runningThreads.put(name, new FfprobeAnalyzer(this, name));
            runningThreads.get(name).start();
        }
    }

    /**
     * Adds files to the list of files held ready for processing.
     * @param files to add
     */
    public void addFiles(Map<String, String> files){
        this.files.putAll(files);
    }

    /**
     * Adds files and starts processing.
     * @param files to process
     */
    public void processFiles(Map<String, String> files){
        addFiles(files);
        startBatch();
    }

    /**
     * Callback routine for handeling errors and successes
     * @param fileName the file for which the results apply
     * @param analysisResult the results created in XML form
     * @param analysisErrors error text generated by the CLI tool
     * @param error errors raised by the callee 
     */
    @Override
    synchronized public void incommingEvent(String fileName, InputStream analysisResult,
                               String analysisErrors, Exception error) throws IOException, SAXException {
        runningThreads.remove(fileName);
        if (error != null) {
            failedFiles.put(fileName, analysisErrors);
            error.printStackTrace();
            return;
        }
        Document ffprobeDoc = createFfprobeDocForDOMS(analysisResult);
        }

    private Document createFfprobeDocForDOMS(InputStream analysisResult) throws IOException, SAXException {
        return docBuilder.parse(analysisResult);
    }
}
